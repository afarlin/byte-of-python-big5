# 面向物件編程 {#oop}

在至今我們編寫的所有程式中，我們曾圍繞函數設計我們的程式，也就是那些能夠處理資料的代碼塊。這被稱作_面向過程（Procedure-oriented）_的編程方式。還有另外一種組織起你的程式的方式，它將資料與功能進行組合，並將其包裝在被稱作『物件』的東西內。在大多數情況下，你可以使用過程式編程，但是當你需要編寫一個大型程式或面對某一更適合此方法的問題時，你可以考慮使用面向物件式的編程技術。

類與物件是面向物件編程的兩個主要方面。一個**類（Class）**能夠創建一種新的_類型（Type）_，其中**物件（Object）**就是類的**實例（Instance）**。可以這樣來類比：你可以擁有類型 `int` 的變量，也就是說存儲整數的變量是 `int` 類的實例（物件）。

> **針對靜態編程語言程式員的提示**
> 
> 請注意，即使是整數也會被視為物件（`int` 類的物件）。這不同于 C++ 與 Java（1.5 版之前），在它們那兒整數是原始內置類型。[^1]
> 
> 有關類的更多詳細資訊，請參閱 `help(int)`。
> 
> C# 與 Java 1.5 程式員會發現這與_裝箱與拆箱（Boxing and Unboxing）_概念[^2]頗有相似之處。

物件可以使用_屬于_它的普通變量來存儲資料。這種從屬于物件或類的變量叫作**欄位（Field）**。物件還可以使用_屬于_類的函數來實現某些功能，這種函數叫作類的**方法（Method）**。這兩個術語很重要，它有助于我們區分函數與變量，哪些是獨立的，哪些又是屬于類或物件的。總之，欄位與方法通稱類的**屬性（Attribute）**。

欄位有兩種類型——它們屬于某一類的各個實例或物件，或是從屬于某一類本身。它們被分別稱作**實例變量（Instance Variables）**與**類變量（Class Variables）**。

通過 `class` 關鍵字可以創建一個類。這個類的欄位與方法可以在縮進代碼塊中予以列出。

## `self` {#self}

類方法與普通函數只有一種特定的區別——前者必須有一個額外的名字，這個名字必須添加到參數列表的開頭，但是你*不用*在你調用這個功能時為這個參數賦值，Python 會為它提供。這種特定的變量引用的是物件_本身_，按照慣例，它被賦予 `self` 這一名稱。

盡管你可以為這一參數賦予任何名稱，但是_強烈推薦_你使用 `self` 這一名稱——其他的任何一種名稱絕對會引人皺眉。使用一個標准名稱能帶來諸多好處——任何一位你的程式的讀者能夠立即認出它，甚至是專門的 IDE（Integrated Development Environments，集成開發環境）也可以為你提供幫助，只要你使用了 `self` 這一名稱。

> **針對 C++/Java/C# 程式員的提示**
> 
> Python 中的 `self` 相當于 C++ 中的指標以及 Java 與 C# 中的 `this` 指標。

你一定會在想 Python 是如何給 `self` 賦值的，以及為什麼你不必給它一個值。一個例子或許會讓這些疑問得到解答。假設你有一個 `MyClass` 的類，這個類下有一個實例 `myobject`。當你調用一個這個物件的方法，如 `myobject.method(arg1, arg2)` 時，Python 將會自動將其轉換成 `MyClass.method(myobject, arg1, arg2)`——這就是 `self` 的全部特殊之處所在。

這同時意味著，如果你有一個沒有參數的功能，你依舊必須擁有一個參數——`self`。

## 類 {#class}

最簡單的類（Class）可以通過下面的案例來展示（保存為 `oop_simplestclass.py`）：

<pre><code class="lang-python">{% include "./programs/oop_simplestclass.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/oop_simplestclass.txt" %}</code></pre>

**它是如何工作的**

我們通過使用 `class` 語句與這個類的名稱來創建一個新類。在它之後是一個縮進的語句塊，代表這個類的主體。在本案例中，我們創建的是一個空代碼塊，使用 `pass` 語句予以標明。

然後，我們通過採用類的名稱後跟一對括弧的方法，給這個類創建一個物件（或是實例，我們將在[後面的章節](#init)中了解有關實例的更多內容）。為了驗証我們的操作是否成功，我們通過直接將它們列印出來來確認變量的類型。結果告訴我們我們在 `Person` 類的 `__main__` 模組中擁有了一個實例。

要注意到在本例中還會列印出電腦記憶體中存儲你的物件的位址。案例中給出的位址會與你在你的電腦上所能看見的位址不相同，因為 Python 會在它找到的任何空間來存儲物件。

## 方法

我們已經在前面討論過類與物件一如函數那般都可以帶有方法（Method），唯一的不同在于我們還擁有一個額外的 `self` 變量。現在讓我們來看看下面的例子（保存為 `oop_method.py`）。

<pre><code class="lang-python">{% include "./programs/oop_method.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/oop_method.txt" %}</code></pre>

**它是如何工作的**

這里我們就能看見 `self` 是如何行動的了。要注意到 `say_hi` 這一方法不需要參數，但是依舊在函數定義中擁有 `self` 變量。

## `__init__` 方法 {#init}

Python 中的有不少類它們的名稱具有著特殊的意義。現在我們要了解的就是 `__init__` 方法的意義。

`__init__` 方法會在類的物件被實例化（Instantiated）時立即運行。這一方法可以對任何你想進行操作的目標物件進行*初始化（Initialization）*操作。這里你要注意在 init 的前後加上的雙下劃線。

案例（保存為 `oop_init.py`）：

<pre><code class="lang-python">{% include "./programs/oop_init.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/oop_init.txt" %}</code></pre>

**它是如何工作的**

在本例中，我們定義 `__init__` 方法用以接受 `name` 參數（與更普遍的 `self` 一道）。在這里，我們創建了一個欄位，同樣稱為 `name`。要注意到盡管它們的名字都是『name』，但這是兩個不相同的變量。雖說如此，但這並不會造成任何問題，因為點號 `self.name` 意味著這個叫作『name』的東西是某個叫作『self』的物件的一部分，而另一個 `name` 則是一個局部變量。由于我們已經如上這般明確指出了我們所指的是哪一個名字，所以它不會引發混亂。

當我們在 `Person` 類下創建新的實例 `p` 時，我們採用的方法是先寫下類的名稱，後跟括在括弧中的參數，形如：`p = Person('Swaroop')`。

我們不會顯式地調用 `__init__` 方法。
這正是這個方法的特殊之處所在。

現在，我們可以使用我們方法中的 `self.name` 欄位了，使用的方法在 `say_hi` 方法中已經作過說明。

## 類變量與物件變量 {#class-obj-vars}[^3]

我們已經討論過了類與物件的功能部分（即方法），現在讓我們來學習它們的資料部分。資料部分——也就是欄位——只不過是_綁定（Bound）_到類與物件的**命名空間（Namespace）**的普通變量。這就代表著這些名稱僅在這些類與物件所存在的上下文中有效。這就是它們被稱作_『命名空間』_的原因。

_欄位（Filed）_有兩種類型——類變量與物件變量，它們根據究竟是類還是物件_擁有_這些變量來進行分類。

**類變量（Class Variable）**是共用的（Shared）——它們可以被屬于該類的所有實例訪問。該類變量只擁有一個副本，當任何一個物件對類變量作出改變時，發生的變動將在其他所有實例中都會得到體現。

**物件變量（Object variable）**由類的每一個獨立的物件或實例所擁有。在這種情況下，每個物件都擁有屬于它自己的欄位的副本，也就是說，它們不會被共用，也不會以任何方式與其他不同實例中的相同名稱的欄位產生關聯。下面一個例子可以幫助你理解（保存為 `oop_objvar.py`）：

<pre><code class="lang-python">{% include "./programs/oop_objvar.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/oop_objvar.txt" %}</code></pre>

**它是如何工作的**

這是一個比較長的案例，但是它有助于展現類與物件變量的本質。在本例中，`population` 屬于 `Robot` 類，因此它是一個類變量。`name` 變量屬于一個物件（通過使用 `self` 分配），因此它是一個物件變量。

因此，我們通過 `Robot.population` 而非 `self.population` 引用 `population` 類變量。我們對于 `name` 物件變量採用 `self.name` 標記法加以稱呼，這是這個物件中所具有的方法。要記住這個類變量與物件變量之間的簡單區別。同時你還要注意當一個物件變量與一個類變量名稱相同時，類變量將會被隱藏。

除了 `Robot.popluation`，我們還可以使用 `self.__class__.population`，因為每個物件都通過 `self.__class__` 屬性來引用它的類。

`how_many` 實際上是一個屬于類而非屬于物件的方法。這就意味著我們可以將它定義為一個 `classmethod（類方法）` 或是一個 `staticmethod（靜態方法）`，這取決于我們是否知道我們需不需要知道我們屬于哪個類。由于我們已經引用了一個類變量，因此我們使用 `classmethod（類方法）`。

我們使用[裝飾器（Decorator）](./18.more.md#decorator)將 `how_many` 方法標記為類方法。

你可以將裝飾器想象為調用一個包裝器（Wrapper）函數的捷徑，因此啟用 `@classmethod` 裝飾器等價于調用：

```python
how_many = classmethod(how_many)
```

你會觀察到 `__init__` 方法會使用一個名字以初始化 `Robot` 實例。在這一方法中，我們將 `population` 按 1 往上增長，因為我們多增加了一台機器人。你還會觀察到 `self.name` 的值是指定給每個物件的，這體現了物件變量的本質。

你需要記住你*只能*使用 `self` 來引用同一物件的變量與方法。這被稱作*屬性引用（Attribute Reference）*。

在本程式中，我們還會看見針對類和方法的 *文檔字串（DocStrings）* 的使用方式。我們可以在運行時通過 `Robot.__doc__` 訪問類的 文檔字串，對于方法的文檔字串，則可以使用 `Robot.say_hi.__doc__`。

在 `die` 方法中，我們簡單地將 `Robot.population` 的計數按 1 向下減少。

所有的類成員都是公開的。但有一個例外：如果你使用資料成員並在其名字中_使用雙下劃線作為字首_，形成諸如 `__privatervar` 這樣的形式，Python 會使用名稱調整（Name-mangling）來使其有效地成為一個私有變量。

因此，你需要遵循這樣的約定：任何在類或物件之中使用的變量其命名應以下劃線開頭，其他所有非此格式的名稱都將是公開的，並可以為其他任何類或物件所使用。請記得這只是一個約定，Python 並不強制如此（除了雙下劃線字首這點）。

> **針對 C++/Java/C# 程式員的提示**
> 
> 所有類成員（包括資料成員）都是_公開的_，並且 Python 中所有的方法都是_虛擬的（Vireual）_。

## 繼承

面向物件編程的一大優點是對代碼的**重用（Reuse）**，重用的一種實現方法就是通過**繼承（Inheritance）**機制。繼承最好是想象成在類之間實現**類型與子類型（Type and Subtype）**關系的工具。

現在假設你希望編寫一款程式來追蹤一所大學里的老師和學生。有一些特征是他們都具有的，例如姓名、年齡和位址。另外一些特征是他們獨有的，一如教師的薪水、課程與假期，學生的成績和學費。

你可以為每一種類型創建兩個獨立的類，並對它們進行處理。但增添一條共有特征就意味著將其添加進兩個獨立的類。這很快就會使程式變得笨重。

一個更好的方法是創建一個公共類叫作 `SchoolMember`，然後讓教師和學生從這個類中_繼承（Inherit）_，也就是說他們將成為這一類型（類）的子類型，而我們就可以向這些子類型中添加某些該類獨有的特征。

這種方法有諸多優點。如果我們增加或修改了 `SchoolMember` 的任何功能，它將自動反映在子類型中。舉個例子，你可以通過簡單地向 SchoolMember 類進行操作，來為所有老師與學生添加一條新的 ID 卡欄位。不過，對某一子類型作出的改動並不會影響到其他子類型。另一大優點是你可以將某一老師或學生物件看作 `SchoolMember` 的物件並加以引用，這在某些情況下會大為有用，例如清點學校中的成員數量。這被稱作**多態性（Polymorphism）**，在任何情況下，如果父類型希望，子類型都可以被替換，也就是說，該物件可以被看作父類的實例。

同時還需要注意的是我們重用父類的代碼，但我們不需要再其他類中重複它們，當我們使用獨立類型時才會必要地重複這些代碼。

在上文設想的情況中，`SchoolMember` 類會被稱作**基類（Base Class）**[^4]或是**超類（Superclass）**。`Teacher` 和 `Student` 類會被稱作**派生類（Derived Classes）**[^5]或是**子類（Subclass）**。

我們將通過下面的程式作為案例來進行了解（保存為 `oop_subclass.py`）：

<pre><code class="lang-python">{% include "./programs/oop_subclass.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/oop_subclass.txt" %}</code></pre>

**它是如何工作的**

要想使用繼承，在定義類[^6]時我們需要在類後面跟一個包含基類名稱的元組。然後，我們會注意到基類的 `__init__` 方法是通過 `self` 變量被顯式調用的，因此我們可以初始化物件的基類部分。下面這一點很重要，需要牢記——因為我們在 `Teacher` 和 `Student` 子類中定義了 `__init__` 方法，Python 不會自動調用基類 `SchoolMember` 的構造函數，你必須自己顯式地調用它。

相反，如果我們_沒有_在一個子類中定義一個 `__init__` 方法，Python 將會自動調用基類的構造函數。

我們會觀察到，我們可以通過在方法名前面加上類名作為字首，再將其傳入 `self` 和其余變量中，來調用基類的方法。

在這里你需要注意，當我們使用 `SchoolMember` 類的 `tell` 方法時，我們可以將 `Teacher` 或 `Studtne` 的實例看作 `SchoolMember` 的實例。

同時，你會發現被調用的是子類型的 `tell` 方法，而不是 `SchoolMember` 的 `tell` 方法。理解這一問題的一種思路是 Python *總會*從當前的實際類型中開始尋找方法，在本例中即是如此。如果它找不到對應的方法，它就會在該類所屬的基本類中依順序逐個尋找屬于基本類的方法，這個基本類是在定義子類時後跟的元組指定的。

這里有一條有關術語的注釋——如果繼承元組（Inheritance Tuple）中有超過一個類，這種情況就會被稱作**多重繼承（Multiple Inheritance）**。

`end` 參數用在超類的 `tell()` 方法的 `print` 函數中，目的是列印一行並允許下一次列印在同一行繼續。這是一個讓 `print` 能夠不在列印的末尾列印出 `\n` （新行換行符）符號的小竅門。

## 總結

我們已經探索了有關類和物件的各個方面，還有與它們相關的各類術語。我們還了解了面向物件編程的益處與陷阱。Python 是高度面向物件的，從長遠來看，了解這些概念對你大有幫助。

接下來，我們將學習如何處理輸入與輸出，以及如何在 Python 中訪問文件。



----
[^1]: 原文作 Primitive native types，沈潔元譯本表達為『把整數純粹作為類型』。Primitive type 翻譯作『原始類型』，也稱作『內置類型』，因此此處也可以翻譯成『基本內置類型』。

[^2]: 沈潔元譯本譯作『封裝與解封裝』。

[^3]: 本節標題原文作 Class And Object Variables，沈潔元譯本譯作『類與物件的方法』。

[^4]: 沈潔元譯本譯作『基本類』。

[^5]: 沈潔元譯本譯作『導出類』。

[^6]: 此處的類即派生類或子類。
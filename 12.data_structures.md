# 資料結構 {#data-structures}

資料結構（Data Structures）基本上人如其名——它們只是一種*結構*，能夠將一些*資料*聚合在一起。換句話說，它們是用來存儲一系列相關資料的集合。

Python 中有四種內置的資料結構——_列表（List）、元組（Tuple）、字典（Dictionary）和集合（Set）_。我們將了解如何使用它們，並利用它們將我們的編程之路變得更加簡單。

## 列表

`列表` 是一種用于保存一系列有序專案的集合，也就是說，你可以利用列表保存一串專案的*序列*。想象起來也不難，你可以想象你有一張購物清單，上面列出了需要購買的商品，除開在購物清單上你可能為每件物品都單獨列一行，在 Python 中你需要在它們之間多加上一個逗號。

專案的列表應該用方括弧括起來，這樣 Python 才能理解到你正在指定一張列表。一旦你創建了一張列表，你可以添加、移除或搜索列表中的專案。既然我們可以添加或刪除專案，我們會說列表是一種*可變的（Mutable）*資料類型，意即，這種類型是可以被改變的。

## 有關物件與類的快速介紹

雖然到目前為止我經常推遲有關物件（Object）與類（Class）的討論，但現在對它們進行稍許解釋能夠有助于你更好地理解列表。我們將在[後面的章節](./14.oop.md#oop)討論有關它們的更多細節。

列表是使用物件與類的實例。當我們啟用一個變量 `i` 並將整數 `5` 賦值給它時，你可以認為這是在創建一個 `int` *類*（即類型）之下的*物件*（即實例） `i`。實際上，你可以閱讀 `help(int)` 來了解更多內容。

一個類也可以帶有*方法（Method）*，也就是說對這個類定義僅對于它啟用某個函數。只有當你擁有一個屬于該類的物件時，你才能使用這些功能。舉個例子，Python 為 `list` 類提供了一種 `append` 方法，能夠允許你向列表末尾添加一個專案。例如 `mylist.append('an item')` 將會向列表 `mylist` 添加一串字串。在這里要注意到我們通過使用點號的方法來訪問物件。

一個類同樣也可以具有*欄位（Field）*，它是只為該類定義且只為該類所用的變量。只有當你擁有一個屬于該類的物件時，你才能夠使用這些變量或名稱。欄位同樣可以通過點號來訪問，例如 `mylist.field`。

案例（保存為 `ds_using_list.py`）：

<pre><code class="lang-python">{% include "./programs/ds_using_list.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_using_list.txt" %}</code></pre>

**它是如何工作的**

變量 `shoplist` 是一張為即將前往市場的某人准備的購物清單。在 `shoplist` 中，我們只存儲了一些字串，它們是我們需要購買的物品的名稱，但是你可以向列表中添加_任何類型的物件_，包括數字，甚至是其他列表。

我們還使用 `for...in` 迴圈來遍歷列表中的每一個專案。學習到現在，你必須有一種列表也是一個序列的意識。有關序列的特性將會在[稍後的章節](#sequence)予以討論。

在這里要注意在調用 `print` 函數時我們使用 `end` 參數，這樣就能通過一個空格來結束輸出工作，而不是通常的換行。

接下來，如我們討論過的那般，我們通過列表物件中的 `append` 方法向列表中添加一個物件。然後，我們將列表簡單地傳遞給 `print` 函數，整潔且完整地列印出列表內容，以此來檢查專案是否被切實地添加進列表之中。

接著，我們列表的 `sort` 方法對列表進行排序。在這里要著重理解到這一方法影響到的是列表本身，而不會返回一個修改過的列表——這與修改字串的方式並不相同。同時，這也是我們所說的，列表是_可變的（Mutable）_而字串是_不可變的（Immutable）_。

隨後，當我們當我們在市場上買回某件商品時，我們需要從列表中移除它。我們通過使用 `del` 語句來實現這一需求。在這里，我們將給出我們希望從列表中移除的商品，`del` 語句則會為我們從列表中移除對應的專案。我們希望移除列表中的第一個商品，因此我們使用 `del shoplise[0]`（要記住 Python 從 0 開始計數）。

如果你想了解列表物件定義的所有方法，可以通過 `help(list)` 來了解更多細節。

## 元組

元組（Tuple）用于將多個物件保存到一起。你可以將它們近似地看作列表，但是元組不能提供列表類能夠提供給你的廣泛的功能。元組的一大特征類似于字串，它們是*不可變的*，也就是說，你不能編輯或更改元組。

元組是通過特別指定專案來定義的，在指定專案時，你可以給它們加上括弧，並在括弧內部用逗號進行分隔。

元組通常用于保証某一語句或某一用戶定義的函數可以安全地採用一組數值，意即元組內的數值不會改變。

案例（保存為 `ds_using_tuple.py`）：

<pre><code class="lang-python">{% include "./programs/ds_using_tuple.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_using_tuple.txt" %}</code></pre>

**它是如何工作的**

變量 `zoo` 指的是一個包含專案的元組。我們能夠看到 `len` 函數在此處用來獲取元組的長度。這也表明元組同時也是一個[序列](#sequence)。

現在，我們將這些動物從即將關閉的老動物園（Zoo）轉移到新的動物園中。因此，`new_zoo` 這一元組包含了一些本已存在的動物以及從老動物園轉移過去的動物。讓我們回到話題中來，在這里要注意到元組中所包含的元組不會失去其所擁有的身份。

如同我們在列表里所做的那般，我們可以通過在方括弧中指定專案所處的位置來訪問元組中的各個專案。這種使用方括弧的形式被稱作_索引（Indexing）_運算符。我們通過指定 `new_zoo[2]` 來指定 `new_zoo` 中的第三個專案，我們也可以通過指定 `new_zoo[2][2]` 來指定 `new_zoo` 元組中的第三個專案中的第三個專案[^1]。一旦你習慣了這種語法你就會覺得這其實非常簡單。

> **包含 0 或 1 個專案的元組**
> 
> 一個空的元組由一對圓括弧構成，就像 `myempty = ()` 這樣。然而，一個只擁有一個專案的元組並不像這樣簡單。你必須在第一個（也是唯一一個）專案的後面加上一個逗號來指定它，如此一來 Python 才可以識別出在這個運算式想表達的究竟是一個元組還是只是一個被括弧所環繞的物件，也就是說，如果你想指定一個包含專案 `2` 的元組，你必須指定 `singleton = (2, )`。

<!-- -->

> **針對 Perl 程式員的提示**
> 
> 列表中的列表不會丟失其標識，即列表不會像在 Perl 里那般會被打散（Flattened）。這同樣也適用于元組中的元組、列表中的元組或元組中的列表等等情況。對于 Python 而言，它們只是用一個物件來存儲另一個物件，不過僅此而已。

## 字典

字典就像一本位址簿，如果你知道了他或她的姓名，你就可以在這里找到其位址或是能夠聯系上對方的更多詳細資訊，換言之，我們將*鍵值（Keys）*（即姓名）與*值（Values）*（即位址等詳細資訊）聯立到一起。在這里要注意到鍵值必須是唯一的，正如在現實中面對兩個完全同名的人你沒辦法找出有關他們的正確資訊。

另外要注意的是你只能使用不可變的物件（如字串）作為字典的鍵值，但是你可以使用可變或不可變的物件作為字典中的值。基本上這段話也可以翻譯為你只能使用簡單物件作為鍵值。

在字典中，你可以通過使用符號構成 `d = {key : value1 , key2 : value2}` 這樣的形式，來成對地指定鍵值與值。在這里要注意到成對的鍵值與值之間使用冒號分隔，而每一對鍵值與值則使用逗號進行區分，它們全都由一對花括弧括起。

另外需要記住，字典中的成對的鍵值—值配對不會以任何方式進行排序。如果你希望為它們安排一個特別的次序，只能在使用它們之前自行進行排序。

你將要使用的字典是屬于 `dict` 類下的實例或物件。

案例（保存為 `ds_using_dict.py`）：

<pre><code class="lang-python">{% include "./programs/ds_using_dict.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_using_dict.txt" %}</code></pre>

**它是如何工作的**

我們通過已經討論過的符號體系來創建字典 `ab`。然後我們通過使用索引運算符來指定某一鍵值以訪問相應的鍵值—值配對，有關索引運算符的方法我們已經在列表與元組部分討論過了。你可以觀察到這之中的語法非常簡單。

我們可以通過我們的老朋友——`del` 語句——來刪除某一鍵值—值配對。我們只需指定字典、包含需要刪除的鍵值名稱的索引算符，並將其傳遞給 `del` 語句。這一操作不需要你知道與該鍵值相對應的值。

接著，我們通過使用字典的 `item` 方法來訪問字典中的每一對鍵值—值配對資訊，這一操作將返回一份包含元組的列表，每一元組中則包含了每一對相應的資訊——鍵值以及其相應的值。我們檢索這一配對，並通過 `for...in` 迴圈將每一對配對的資訊相應地分配給 `name` 與 `address` 變量，並將結果列印在 `for` 代碼塊中。

如果想增加一堆新的鍵值—值配對，我們可以簡單地通過使用索引運算符訪問一個鍵值並為其分配與之相應的值，就像我們在上面的例子中對 Guido 鍵值所做的那樣。

我們可以使用 `in` 運算符來檢查某對鍵值—值配對是否存在。

要想了解有關 `dict` 類的更多方法，請參閱 `help(dict)`。

> **關鍵字參數與字典**
> 
> 如果你曾在你的函數中使用過關鍵字參數，那麼你就已經使用過字典了！你只要這麼想——你在定義函數時的參數列表時，就指定了相關的鍵值—值配對。當你在你的函數中訪問某一變量時，它其實就是在訪問字典中的某個鍵值。（在編譯器設計的術語中，這叫作_符號表（Symbol Table）_）

## 序列 {#sequence}

列表、元組和字串可以看作序列（Sequence）的某種表現形式，可是究竟什麼是序列，它又有什麼特別之處？

序列的主要功能是*資格測試（Membership Test）*（也就是 `in` 與 `not in` 運算式）和*索引操作（Indexing Operations）*，它們能夠允許我們直接獲取序列中的特定專案。

上面所提到的序列的三種形態——列表、元組與字串，同樣擁有一種*切片（Slicing）*運算符，它能夠允許我們序列中的某段切片——也就是序列之中的一部分。

案例（保存為 `ds_seq.py`）：

<pre><code class="lang-python">{% include "./programs/ds_seq.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_seq.txt" %}</code></pre>

**它是如何工作的**

首先，我們已經了解了如何通過使用索引來獲取序列中的各個專案。這也被稱作_下標操作（Subscription Operation）_。如上所示，每當你在方括弧中為序列指定一個數字，Python 將獲取序列中與該位置編號相對應的專案。要記得 Python 從 0 開始計數。因此 `shoplist[0]` 將獲得 `shoplist` 序列中的第一個專案，而 `shoplist[3]` 將獲得第四個專案。

索引操作也可以使用負數，在這種情況下，位置計數將從佇列的末尾開始。因此，`shoplist[-1]` 指的是序列的最後一個專案，`shoplist[-2]` 將獲取序列中倒數第二個專案。

你需要通過指定序列名稱來進行序列操作，在指定時序列名稱後面可以跟一對數字——這是可選的操作，這一對數字使用方括弧括起，並使用冒號分隔。在這里需要注意，它與你至今為止使用的索引操作顯得十分相像。但是你要記住數字是可選的，冒號卻不是。

在切片操作中，第一個數字（冒號前面的那位）指的是切片開始的位置，第二個數字（冒號後面的那位）指的是切片結束的位置。如果第一位數字沒有指定，Python 將會從序列的起始處開始操作。如果第二個數字留空，Python 將會在序列的末尾結束操作。要注意的是切片操作會在開始處返回 _start_，並在 _end_ 前面的位置結束工作。也就是說，序列切片將包括起始位置，但不包括結束位置。

因此，`shoplist[1:3]` 返回的序列的一組切片將從位置 1 開始，包含位置 2 並在位置 3 時結束，因此，這塊*切片*返回的是兩個專案。類似地，`shoplist[:]` 返回的是整個序列。

你同樣可以在切片操作中使用負數位置。使用負數時位置將從序列末端開始計算。例如，`shoplist[:-1]` 強返回一組序列切片，其中不包括序列的最後一項專案，但其他所有專案都包含其中。

你同樣可以在切片操作中提供第三個參數，這一參數將被視為切片的_步長（Step）_（在默認情況下，步長大小為 1）：

```python
>>> shoplist = ['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::1]
['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::2]
['apple', 'carrot']
>>> shoplist[::3]
['apple', 'banana']
>>> shoplist[::-1]
['banana', 'carrot', 'mango', 'apple']
```

你會注意到當步長為 2 時，我們得到的是第 0、2、4…… 位專案。當步長為 3 時，我們得到的是第 0、3……位專案。

你可以在 Python 解釋器中交互地嘗試不同的切片方式的組合，這將幫助你立即看到結果。序列的一大優點在于你可以使用同樣的方式訪問元組、列表與字串。

## 集合

集合（Set）是簡單物件的_無序_集合（Collection）。當集合中的專案存在與否比起次序或其出現次數更加重要時，我們就會使用集合。

通過使用集合，你可以測試某些物件的資格或情況，檢查它們是否是其他集合的子集，找到兩個集合的交集，等等。

```python
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
```

**它是如何工作的**

這個案例幾乎不言自明，因為它涉及的是學校所教授的數學里的基礎集合知識。

## 引用[^2]

當你創建了一個物件並將其分配給某個變量時，變量只會_查閱（Refer）_某個物件，並且它也不會代表物件本身。也就是說，變量名只是指向你電腦記憶體中存儲了相應物件的那一部分。這叫作將名稱*綁定（Binding）*給那一個物件。

一般來說，你不需要去關心這個，不過由于這一引用操作困難會產生某些微妙的效果，這是需要你注意的：

案例（保存為 `ds_reference.py`）：

<pre><code class="lang-python">{% include "./programs/ds_reference.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_reference.txt" %}</code></pre>

**它是如何工作的**

大部分解釋已經在注釋中提供。

你要記住如果你希望創建一份諸如序列等複雜物件的副本（而非整數這種簡單的_物件（Object）_），你必須使用切片操作來制作副本。如果你僅僅是將一個變量名賦予給另一個名稱，那麼它們都將『查閱』同一個物件，如果你對此不夠小心，那麼它將造成麻煩。

> **針對 Perl 程式員的提示**
> 
> 要記住列表的賦值語句**不會**創建一份副本。你必須使用切片操作來生成一份序列的副本。

## 有關字串的更多內容 {#more-strings}

在早些時候我們已經詳細討論過了字串。還有什麼可以知道的嗎？還真有，想必你還不知道字串同樣也是一種物件，並且它也具有自己的方法，可以做到檢查字串中的一部分或是去掉空格等幾乎一切事情！

你在程式中使用的所有字串都是 `str` 類下的物件。下面的案例將演示這種類之下一些有用的方法。要想獲得這些方法的完成清單，你可以查閱 `help(str)`。

案例（保存為 `ds_str_methods.py`）：

<pre><code class="lang-python">{% include "./programs/ds_str_methods.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/ds_str_methods.txt" %}</code></pre>

**它是如何工作的**

在這里，我們會看見一此操作中包含了好多字串方法。`startwith` 方法用于查找字串是否以給定的字串內容開頭。`in` 運算符用以檢查給定的字串是否是查詢的字串中的一部分。

`find` 方法用于定位字串中給定的子字串的位置。如果找不到相應的子字串，`find` 會返回 -1。`str` 類同樣還擁有一個簡潔的方法用以 `聯結（Join）`序列中的專案，其中字串將會作為每一專案之間的分隔符，並以此生成並返回一串更大的字串。

## 總結

我們已經詳細探討了 Python 中內置的多種不同的資料結構。這些資料結構對于編寫大小適中的 Python 程式而言至關重要。

現在我們已經具備了諸多有關 Python 的基本知識，接下來我們將會了解如何設計並編寫一款真實的 Python 程式。



****
[^1]: 第一個『第三個專案』可以是指元組中的元組。

[^2]: 原文作『Reference』，沈潔元譯本譯作『參考』。此處譯名尚存疑，如有更好的翻譯建議還請指出。
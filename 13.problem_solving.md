# 解決問題

我們已經探索了 Python 語言中的許多部分，現在我們將通過設計並編寫一款程式來了解如何把這些部分組合到一起。這些程式一定是能_做到_一些有用的事情。這其中的方法就是去學習如何靠你自己來編寫一份 Python 腳本。

## 問題

我們希望解決的問題如下：

> 我想要一款能為我所有重要的文件創建備份的程式。

雖然這是一個簡單的問題，但是其中並沒有足夠的資訊有助于讓我們開始規劃一份解決方案。我們需要進行一些*分析（Analysis）*。例如，我們應該如何指定_哪些_文件是我們需要備份的？它們應該_如何_進行備份？儲存到_哪里_?

在正確地分析了這些問題過後，我們便開始*設計（Design）*我們的程式。我們將列出一份關于我們的程式應如何運轉的清單。在這個案例中，我已經編寫了如下清單來說明_我_將如何工作。如果由你來設計程式，你可能不會做出同樣的分析，因為每個人都有其自己的行事方式，所以出現不同是完全正常、且正確的。

- 需要備份的文件與目錄應在一份列表中予以指定。
- 備份必須存儲在一個主備份目錄中。
- 備份文件將打包壓縮成 zip 文件。
- zip 壓縮文件的文件名由當前日期與時間構成。
- 我們使用在任何 GNU/Linux 或 Unix 發行版中都會默認提供的標准 `zip` 命令進行打包。在這里你需要了解到只要有命令行界面，你就可以使用任何需要用到的壓縮或歸檔命令。

> **針對 Windows 用戶的提示**
> 
> Windows 用戶可以從 [GnuWin32 專案頁面](http://gnuwin32.sourceforge.net/packages/zip.htm) 上下載並[安裝](http://gnuwin32.sourceforge.net/downlinks/zip.php) `zip` 命令，並將 `C:\Program Files\GnuWin32\bin` 添加至你的系統的 `PATH` 環境變量中，這一操作過程與[我們為使系統識別 Python 命令本身所做的事情](./installation.md#dos-prompt)相同。

## 解決方案

由于我們的程式設計方案現在已經相當穩定，我們便可以開始編寫代碼，這個過程我們稱之為*實現（Implementation）*我們的解決方案。

將下述代碼保存為 `backup_ver1.py`：

<pre><code class="lang-python">{% include "./programs/backup_ver1.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/backup_ver1.txt" %}</code></pre>

現在，我們正處于*測試（Testing）*階段，在這一階段我們測試我們的程式是否能正常工作。如果其行為不符合我們的預期，那麼我們需要對我們的程式進行 *Debug* 工作，也就是說，移除程式中的 *Bug*（錯誤）。

如果上面的程式不能夠正常工作，複制列印在 `Zip command is` 後面的命令，將其粘貼至 shell（在 GNU/Linux 與 Mac OS X 環境中）或 `cmd`（對于 Windows 環境），看看存在什麼錯誤並嘗試將其修複。同時你還需要檢查 zip 命令手冊來看看是不是哪里存在錯誤。如果這條命令成功運行，那麼可能是錯誤可能存在在 Python 程式本身之中，因此你需要檢查你的程式是否如上面所展示那番。

**它是如何工作的**

你會注意到我們是如何一步步將我們的*設計*轉化為*代碼*的。

我們首先導入 `os` 與 `time` 模組以准備使用它們。然後，我們在 `source` 列表中指定我們需要備份的文件與目錄。我們需要存儲我們所有備份文件的目標目錄在 `target_dir` 變量中予以指定。我們將要創建的 zip 歸檔文件的名字由當前日期與時間構成，在這里通過 `time.strftime()` 函數來創建。文件名將以 `.zip` 作為副檔名，並存儲在 `target_dir` 目錄中。

在這里要注意 `os.sep` 變量的使用方式——它將根據你的作業系統給出相應的分隔符，在 GNU/Linux 與 Unix 中它會是 `'/'`，在 Windows 中它會是 `'\\'`，在 Mac OS 中它會是 `':'`。使用 `os.sep` 而非直接使用這些字符有助于使我們的程式變得可移植，從而可以在上述這些系統中都能正常工作。

`time.strftime()` 函數會遵循某些格式（Specification），其中一種就如我們在上方程式中所使用的那樣。`%Y` 將被替換成帶有具體世紀的年份。`%m` 將會被替換成以 `01` 至 `12` 的十進制數所表示的月份。有關這些格式的全部列表可以在[ Python 參考手冊](http://docs.python.org/3/library/time.html#time.strftime)中查詢到。

我們使用_連接（Concatenates）_字串的加法（`+`）運算符來創建目標 zip 文件的文件名，也就是說，它將兩個字串連接到一起並返回一個新的字串。然後，我們創建了一串字串 `zip_command`，其中包括了我們要執行的命令。如果這條命令不能正常工作，你可以把它拷貝到 Shell（GNU/Linux 終端或 DOS 提示符）中進行檢查。

我們使用的 `zip` 命令會有一些選項與參數需要傳遞。`-r` 選項用以指定 zip 命令應該**遞歸地**（**R**ecursively）對目錄進行工作，也就是說它應該包括所有的子文件夾與其中的文件。這兩個選項結合到一起並可以指定一個捷徑作 `-qr`。選項後面跟著的是將要創建的 zip 文件的名稱，再往後是需要備份的文件與目錄的列表。我們通過使用已經討論過並已了解該如何運用的的字串方法 `join` 來將列表 `source` 轉換成字串。

隨後，我們終于可以*運行*這一使用了 `os.system` 函數的命令，這一函數可以使命令像是從*系統*中運行的。也就是說，從 shell 中運行的——如果運行成功，它將返回 `0`，如果運行失敗，將返回一個錯誤代碼。

根據命令運行的結果是成功還是失敗，我們將列印出與之相應的資訊來告訴你備份的結果究竟如何。

就是這樣，我們便創建了一份用以備份我們的重要文件的腳本！

> **針對 Windows 用戶的提示**
> 
> 除了使用雙反斜杠轉義序列，你還可以使用原始字串。例如使用 `'C:\\Documents'` 或 `r'C:\Documents'`。然而，*不*要使用 `'C:\Documents'`，因為它將被識別為你使用了一個未知的轉義序列 `\D` 來結束路徑的輸入。

現在，我們已經擁有了一份可以正常工作的備份腳本，我們可以在任何我們需要備份文件的時候使用它。這被稱作軟件的*操作（Operation）*或*部署（Deployment）*階段。

上面所展示的程式能夠正常工作，但是（通常）第一個程式都不會按照你所期望的進行工作。可能是因為你沒有正確地設計程式，或如果你在輸入代碼時出現了錯誤。出現這些情況時，在恰當的時候，你需要回到設計階段，或者你需要對你的程式進行 Debug 工作。

## 第二版

我們的第一版腳本已經能夠工作了。然而，我們還可以對它作出一些改進，從而使它能夠更好地在每一天都可以正常工作。我們將這一階段稱之為軟件的*維護（Maintenance）*階段。

我認為有一種頗為有用的改進是起用一種更好的文件命名機制——使用_時間_作為文件名，存儲在以當前_日期_為名字的文件夾中，這一文件夾則照常存儲在主備份目錄下。這種機制的第一個有點在于你的備份會以分層的形式予以存儲，從而使得它們能更易于管理。第二個優點是文件名能夠更短。第三個優點在于由于只有當天進行了備份才會創建相應的目錄，獨立的目錄能夠幫助你快速地檢查每天是否都進行了備份。

保存為 `backup_ver2.py`：

<pre><code class="lang-python">{% include "./programs/backup_ver2.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/backup_ver2.txt" %}</code></pre>

**它是如何工作的**

程式的大部分都保持不變。有所改變的部分是我們通過 `os.path.exists` 函數來檢查主文件目錄中是否已經存在了以當前日期作為名稱的子目錄。如果尚未存在，我們通過 `os.mkdir` 函數來創建一個。

## 第三版

第二版在我要制作多份備份時能夠正常工作，但當備份數量過于龐大時，我便很難找出備份之間有什麼區別了。例如，我可能對我的程式或者簡報做了重大修改，然後我想將這些修改與 zip 文件的文件名產生關聯。這可以通過將用戶提供的注釋內容添加到文件名中來實現。

預先提醒：下面給出的程式將不會正常工作，所以不必驚慌，只需跟著案例去做因為你要在里面學上一課。

保存為 `backup_ver3.py`：

<pre><code class="lang-python">{% include "./programs/backup_ver3.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/backup_ver3.txt" %}</code></pre>

**它是如何（不）工作的**

*這個程式它跑不起來！*Python 會說程式之中存在著語法錯誤，這意味著腳本並未擁有 Python 期望看見的結構。當我們觀察 Python 給出的錯誤時，會看見它同時也告訴我們它檢測到錯誤的額地方。所以我們開始從那個地方開始對我們的程式進行 *Debug* 工作。

仔細觀察，我們會發現有一獨立的邏輯行被分成了兩行物理行，但我們並未指定這兩行物理行應該是一起的。基本上，Python 已經發現了該邏輯行中的加法運算符（`+`）沒有任何運算元，因此它不知道接下來應當如何繼續。因此，我們在程式中作出修正。當我們發現程式中的錯誤並對其進行修正時，我們稱為*『錯誤修複（Bug Fixing）』*。

## 第四版

保存為 `backup_ver4.py`：

<pre><code class="lang-python">{% include "./programs/backup_ver4.py" %}</code></pre>

輸出：

<pre><code>{% include "./programs/backup_ver4.txt" %}</code></pre>

**它是如何工作的**

現在程式可以正常工作了！讓我們來回顧一下我們在第三版中所作出的實際的增強工作。我們使用 `input` 函數來接受用戶的注釋內容，並通過 `len` 函數來檢查輸入內容的長度，以檢查用戶是否確實輸入了什麼內容。如果用戶未輸入任何內容而直接敲下了 `enter` 鍵（也許這份備份只是一份例行備份而沒作出什麼特殊的修改），那麼我們將繼續我們以前所做的工作。

不過，如果用戶輸入了某些注釋內容，那麼它將會被附加進 zip 文件的文件名之中，處在 `.zip` 副檔名之前。在這里需要注意的是我們用下劃線替換注釋中的空格——這是因為管理沒有空格的文件名總會容易得多。

## 繼續改進

第四版程式已經是一份對大多數用戶來說都能令人滿意地工作運行的腳本了，不過總會有改進的余地在。例如，你可以在程式中添加 `-v` 選項來指定程式的顯示資訊的_詳盡_[^1]程度，從而使你的程式可以更具說服力，或者是添加 `-q` 選項使程式能_靜默（Quiet）_運行。

另一個可以增強的方向是在命令行中允許額外的文件與目錄傳遞到腳本中。我們可以從 `sys.argv` 列表中獲得這些名稱，然後我們可以通過`list` 類提供的 `extend` 方法把它們添加到我們的 `source` 列表中.

最重要的改進方向是不使用 `os.system` 方法來創建歸檔文件，而是使用 [zipfile](http://docs.python.org/3/library/zipfile.html) 或 [tarfile](http://docs.python.org/3/library/tarfile.html) 內置的模組來創建它們的歸檔文件。這些都是標准庫的一部分，隨時供你在你的電腦上沒有 zip 程式作為沒有外部依賴的情況下使用這些功能。

不過，在上面的例子中，我一直都在使用 `os.system` 這種方式作為創建備份的手段，這樣就能保証案例對于所有人來說都足夠簡單同時也確實有用。

你可以試試編寫第五版腳本嗎？在腳本中使用 [zipfile](http://docs.python.org/3/library/zipfile.html) 模組而非 `os.system` 調用。

## 軟件開發流程

我們已經經歷了開發一款軟件的流程中的各個`階段（Phases）`。現在可以將這些階段總結如下：

1. What/做什麼（分析）
2. How/怎麼做（設計）
3. Do It/開始做（執行）
4. Test/測試（測試與修複錯誤）
5. Use/使用（操作或開發）
6. Maintain/維護（改進）

編寫程式時推薦的一種方式是遵循我們在編寫備份腳本時所經歷的步驟：進行分析與設計；開始實現一個簡單版本；測試並修複錯誤；開始使用以確保工作狀況皆如期望那般。現在，你可以添加任何你所希望擁有的功能，並繼續去重複這一『開始做—測試—使用』迴圈，需要做多少次就去做多少次。

要記住：

> 程式是成長起來的，不是搭建出來的。
> （Software is grown, not built.）
> ——[Bill de hÓra](http://97things.oreilly.com/wiki/index.php/Great_software_is_not_built,_it_is_grown)

## 總結

我們已經看到了如何創建我們自己的 Python 程式與腳本，也了解了編寫這些程式需要經歷的數個階段。或許你會發現我們在本章中學習的內容對于編寫你自己的程式很有幫助，這樣你就能慢慢習慣 Python，同樣包括它解決問題的方式。

接下來，我們將討論面向物件編程。


----
[^1]: 原文作 Verbosity，沈潔元譯本譯作『交互』。